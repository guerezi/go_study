package usecases

import (
	"context"
	"encoding/json"
	"errors"
	"testing"

	"imobiliaria/internal/models"
	cc "imobiliaria/internal/repositories/cache"
	ch "imobiliaria/internal/repositories/cache/mocks"
	db "imobiliaria/internal/repositories/database/mocks"
	errorsUsecase "imobiliaria/internal/usecases/errors"

	"github.com/stretchr/testify/assert"
)

// GENERATED BY HENRY. DO NOT EDIT.

func TestCreateUser(t *testing.T) {
	repo := new(db.Repositories)
	cache := new(ch.Cache)

	usecases := usecases{
		repo:  repo,
		cache: cache,
	}

	ctx := context.Background()
	age := 12

	type Expect struct {
		User  *models.User
		Error error
	}

	tests := []struct {
		Name   string
		Result Expect
		Params *models.User
		Mocks  func()
	}{
		{
			Name: "NameError",
			Result: Expect{
				User:  nil,
				Error: errorsUsecase.NewError("name should be defined", errorsUsecase.ErrorCodeInvalid, nil),
			},
			Params: &models.User{
				Name:  "",
				Email: "gabriel@gmail.com",
				Age:   &age,
			},
			Mocks: func() {},
		},
		{
			Name: "AgeError",
			Result: Expect{
				User:  nil,
				Error: errorsUsecase.NewError("age should be defined", errorsUsecase.ErrorCodeInvalid, nil),
			},
			Params: &models.User{
				Name:  "Gabriel",
				Email: "gabriel@gmail.com",
				Age:   nil,
			},
			Mocks: func() {},
		},
		{
			Name: "Error",
			Result: Expect{
				User:  nil,
				Error: errors.New("I'm a error"),
			},
			Params: &models.User{
				Name:  "Gabrielzinho",
				Email: "gabriel@gmail.com",
				Age:   &age,
			},
			Mocks: func() {
				repo.On("CreateUser", ctx, &models.User{
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   &age,
				}).Return(nil, errors.New("I'm a error")).Once()
			},
		},
		{
			Name: "Success",
			Result: Expect{
				User: &models.User{
					ID:    0,
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   &age,
				},
				Error: nil,
			},
			Params: &models.User{
				Name:  "Gabrielzinho",
				Email: "gabriel@gmail.com",
				Age:   &age,
			},
			Mocks: func() {
				repo.On("CreateUser", ctx, &models.User{
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   &age,
				}).Return(&models.User{
					ID:    0,
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   &age,
				}, nil).Once()
			},
		},
	}

	for _, test := range tests {
		t.Run(test.Name, func(t *testing.T) {
			test.Mocks()
			result, err := usecases.CreateUser(ctx, test.Params)

			t.Log(result)

			assert.Equal(t, test.Result.User, result, "user should be equal")
			// assert.ErrorIs(t, err, test.Result.Error, "error should be equal")
			assert.Equal(t, err, test.Result.Error, "error should be equal")
		})
	}

	repo.AssertExpectations(t)
	cache.AssertExpectations(t)
}

func TestGetUser(t *testing.T) {
	repo := new(db.Repositories)
	cache := new(ch.Cache)

	usecases := usecases{
		repo:  repo,
		cache: cache,
	}

	ctx := context.Background()

	type Expect struct {
		User  *models.User
		Error error
	}

	tests := []struct {
		Name   string
		Result Expect
		Params int
		Mocks  func()
	}{
		{
			Name: "IDError",
			Result: Expect{
				User:  nil,
				Error: errorsUsecase.NewError("id should be defined", errorsUsecase.ErrorCodeInvalid, nil),
			},
			Params: 0,
			Mocks:  func() {},
		},
		{
			Name: "Error",
			Result: Expect{
				User:  nil,
				Error: errorsUsecase.NewError("error getting user from repository", errorsUsecase.ErrorDataBase, errors.New("I'm a error")),
			},
			Params: 1,
			Mocks: func() {
				cache.On("Get", "user:1").Return(nil, errors.New("I'm a error")).Once()
				repo.On("GetUser", ctx, 1).Return(nil, errors.New("I'm a error")).Once()
			},
		},
		{
			Name: "CacheSuccess",
			Result: Expect{
				User: &models.User{
					ID:    1,
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   nil,
				},
				Error: nil,
			},
			Params: 1,
			Mocks: func() {
				cacheData, err := json.Marshal(&models.User{
					ID:    1,
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   nil,
				})

				assert.NoError(t, err, "error should be nil")

				cache.On("Get", "user:1").Return(cacheData, nil).Once()
			},
		},
		{
			Name: "Success",
			Result: Expect{
				User: &models.User{
					ID:    1,
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   nil,
				},
				Error: nil,
			},
			Params: 1,
			Mocks: func() {
				cacheData, err := json.Marshal(&models.User{
					ID:    1,
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   nil,
				})

				assert.NoError(t, err, "error should be nil")

				cache.On("Get", "user:1").Return(nil, nil).Once()

				repo.On("GetUser", ctx, 1).Return(&models.User{
					ID:    1,
					Name:  "Gabrielzinho",
					Email: "gabriel@gmail.com",
					Age:   nil,
				}, nil).Once()

				cache.On("Set", "user:1", cacheData, cc.DefaultSetExpiration).Return(nil).Once()
			},
		},
	}

	for _, test := range tests {
		t.Run(test.Name, func(t *testing.T) {
			test.Mocks()
			result, err := usecases.GetUser(ctx, test.Params)

			t.Log(result)

			assert.Equal(t, test.Result.User, result, "user should be equal")
			// assert.ErrorIs(t, err, test.Result.Error, "error should be equal")
			assert.Equal(t, err, test.Result.Error, "error should be equal")
		})
	}
	repo.AssertExpectations(t)
	cache.AssertExpectations(t)
}
